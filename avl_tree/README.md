# AVL tree

> 自平衡的二叉搜索树

- 核心: 
    * 固定模式的旋转规则: LL, RR, LR, RL
        + 自己动手话一下就能理解
        + 难在比较优雅的实现, 不过枚举也不是不行
    * dfs平衡
        + 插入时
        + 删除时
        + **选取新父节点时**, 因为取出新节点就相当于执行了一次删除
    * 领养孩子时, 左右子树都存在的情况
        + 合并: 找右子树的最小节点或者左子树的最大节点做父节点-
            - 这里总是取右子树的最左节点做新节点
    * 很多dfs操作
        + dfs更新树高度
        + dfs增删改查
        + dfs旋转


- 结构: 树有树样
    * 节点: 左右子树, 数据
    * 树: 根节点
- 接口: 增, 删, 改, 查
    * 增`insert(v)`, 插入v
        1. dfs二叉搜索找位置
        2. 有插有rebalance, dfs然后顺便rebalance
            - 需要dfs做平衡吗? 需要, 如果只在插入点做平衡, 只能局部平衡
    * 查`contains(v) -> bool`, 查v是否存在
        - dfs二叉搜索找位置
    * ⭐删`rmove(v) -> bool`, 删除v
        1. dfs二叉搜索找位置
        2. 有删有rebalance
        3. 非叶子节点删除要领养孩子(merge)
        4. 需要dfs平衡
    * 树高度, 用于计算平衡因子(左右的差), 选择旋转模式
    * ⭐`merge(left, right)`, 合并左右子树(领养)
        + 这里选取右子树的最小节点作为新的父节点
        + 需要注意rebalance, 因为取出节点相当于删除
    * `take_min(tree)`, 找到子树的最小节点, 拿到所有权
        + 最左节点
        + 需要注意rebalance, 因为取出节点相当于删除
    * ⭐`rebalance(node)`
        + 4种模式旋转: LL, RR, LR, RL, 自行画图理解即可
            + 对于LR, RL的情况, 是要先旋转子树
        + LL, RR, <TT>: `!T`旋
        + LR, RL, <UT>: 先`U`旋, 转换成`<TT>`, 再`!T`旋
    * ⭐`rotate()`: 自行画图理解
        + 右旋/左旋: (左/右)子变父, 旧父变子, 旧父接孙子




